#!/usr/bin/env python3
import os
import re
import ast
import json
import shutil
import logging
import time
from bs4 import BeautifulSoup
import requests
import subprocess

import google.generativeai as genai
from googlesearch import search
from collections import defaultdict

from rich.console import Console
from argparse import ArgumentParser, Namespace
from google.auth.exceptions import DefaultCredentialsError

from nethawk.core.config import Config

from nethawk.extensions.google import GeminiClient

class CVESuggester:
    def __init__(self, config):

        if config:
            self.config = config
        else:
            self.config = Config()

        self.console = Console()
        self.provider = config.get('provider') or config.get('http.cve.provider')
        self.limit = config.get('limit') or config.get('http.cve.provider')
        self.extensions = config.get('extensions') or config.get('http.cve.provider')
        self.categories = config.get('categories') or config.get('http.cve.categories')
        api_key = config.get('api_key') or config.get('api_keys.GEMINI_API_KEY')

        self.model = GeminiClient(api_key=api_key)

    def is_tool_installed(self, tool_name):
        return shutil.which(tool_name) is not None

    def ask_user(self, tool_name):
        if self.is_tool_installed(tool_name):
            answer = self.console.input(f"[[magenta]ASK[/]] [bold red]{tool_name}[/] detected. Do you want to search exploits using {tool_name}? (y/N): ")
            return answer.strip().lower() == "y"
        
        else:
            logging.warning(f"{tool_name} is not installed. Skipping...")
            return False

    def build_gemini_prompt(self, detected_tech):
        return (
            f"""
            You are an experienced penetration tester whose primary objective is to gain initial server-side foothold on target web applications, similar to challenges found on platforms like HackTheBox or TryHackMe.

            You are given a list of detected technologies used on a target web application:

            {detected_tech}

            Your task is to filter this list down to **ONLY technologies that directly present a high likelihood of enabling initial server-side foothold exploitation**. 
            Focus exclusively on vulnerabilities that could lead to remote code execution, misconfiguration, data extraction, direct server access, or significant server-side compromise.

            Include a technology only if it meets **any of the following specific criteria for server-side impact**:
            - It is a known framework, CMS, library, plugin, or server-side software (e.g., WordPress, Laravel, Joomla, Express, Apache, Nginx) that is commonly exploited for **critical server-side vulnerabilities** such as Remote Code Execution (RCE), arbitrary file upload leading to RCE, critical authentication bypass, SQL injection leading to RCE, or direct command injection.
            - It includes a **version number**, and that specific version is known to be vulnerable to **critical server-side CVEs** (e.g., RCE, severe authentication bypass, deserialization, command injection, critical path traversal) that could lead to initial server-side foothold.
            - It is uncommon, significantly outdated, or unmaintained server-side software or a legacy framework that often contains significant unpatched server-side attack surface (e.g., exposed legacy admin panels, niche server-side frameworks with confirmed public exploits).
            - It is a clear indicator of a critical server-side security misconfiguration (e.g., exposed Git repositories, debug frameworks or server-side panels enabling code execution, default credentials for backend services, sensitive environment files accessible).

            **ALWAYS EXCLUDE ALL OF THE FOLLOWING** unless there is a **confirmed and critical server-side CVE for the exact version that directly leads to RCE or server compromise**:
            - Common web servers (e.g., Nginx, Apache) - Exclude unless a **critical RCE or direct server compromise vulnerability** is confirmed for the exact version.
            - Operating systems (e.g., Ubuntu, CentOS) - Exclude unless a **critical, directly exploitable server-side vulnerability** (e.g., kernel exploit, services with RCE) is confirmed for the exact version.
            - CDNs (e.g., Cloudflare, cdnjs, jQuery CDN).
            - **UI libraries and frontend tools (e.g., Bootstrap, Popper, OWL Carousel) - Explicitly exclude these. Client-side vulnerabilities (like XSS) are NOT considered a direct initial server-side foothold for this task.**
            - Common JavaScript libraries (e.g., jQuery, RequireJS) - Exclude, even if a version is present, as they generally lead to client-side vulnerabilities, not direct server-side compromise.
            - Media services or general external tools (e.g., YouTube, Google Fonts, Font Awesome).
            - Generic categories without specific software names or versions (e.g., 'Miscellaneous', 'Other').

            Return ONLY the filtered list in the **original json dictionary format** (do not change the value), like:
            [{{'name': '<name>', 'version': '<version>', 'category': '<category>', 'confidence': '<confidence>', 'group': '<group>'}}]
            """
        )
    
    def filtered_technologies(self, detected_tech):
        
        logging.debug(f'Filtering Technologies: {detected_tech}')
        # prompt = self.build_gemini_prompt(detected_tech)

        # try:
        #     response = self.model.generate_content(prompt)
        #     raw_output = response.text

        #     if isinstance(raw_output, list):
        #         return raw_output

        #     if isinstance(raw_output, str):
        #         cleaned = re.sub(r"^```(?:json)?\s*|\s*```$", "", raw_output, flags=re.DOTALL).strip()
                
        #         try:
        #             return json.loads(cleaned)
                
        #         except json.JSONDecodeError:
        #             return ast.literal_eval(cleaned)

        # except DefaultCredentialsError:
        #     logging.warning("GEMINI_API_KEY is not set. Skipped filtering.")

        # except json.JSONDecodeError as e:
        #     logging.error(f"Invalid JSON: {e}")

        # except Exception as e:
        #     logging.exception(f"Failed to filter: {e}")
        
        filtered_tech = [
            tech for tech in detected_tech
            if tech['group'] in self.categories and 'CDN' not in tech['category']
        ]

        return filtered_tech

    def get_cve_description(self, cve_id):
        url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
        try:
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                data = response.json()
                descriptions = data.get("vulnerabilities", [{}])[0].get("cve", {}).get("descriptions", [])
                for desc in descriptions:
                    if desc.get("lang") == "en":
                        return desc.get("value")
                    
        except Exception as e:
            logging.debug(f"Failed to fetch CVE description: {e}")
        
        return 'No description available.'

    def get_cve_insight(self, description):
        try:
            prompt = f"summarize the vulnerability description into 8-15 words: {description}"
            response = self.model.generate_content(prompt)
            return response.text.strip()
        
        except DefaultCredentialsError:
            pass
        
        except Exception as e:
            logging.error(f"Insight generation failed: {e}")
        
        return description

    def extract_cve_from_content(self, url):
        try:
            if "github.com" in url:
                raw_url = url.replace("github.com", "raw.githubusercontent.com").replace("/blob/", "/")
            else:
                raw_url = url

            response = requests.get(raw_url, timeout=10)
            if response.status_code == 200:
                content = response.text

                # Match various CVE formats
                cves = set()

                # Standard CVE-xxxx-yyyy
                cves.update(re.findall(r"CVE-\d{4}-\d{4,7}", content, re.IGNORECASE))

                # Ruby-style ['CVE', '2021-32682']
                ruby_matches = re.findall(r"\[\s*['\"]CVE['\"]\s*,\s*['\"](\d{4}-\d{4,7})['\"]\s*\]", content)
                cves.update([f"CVE-{match}" for match in ruby_matches])

                # Comma-separated 'CVE','2021-32682'
                tuple_matches = re.findall(r"['\"]CVE['\"]\s*,\s*['\"](\d{4}-\d{4,7})['\"]", content)
                cves.update([f"CVE-{match}" for match in tuple_matches])

                return list(cves)
            else:
                return []
        except Exception:
            return []
    
    def google_dork_search(self, tech_name, link_limit=3):
        logging.debug(f"Searching '{tech_name}' for PoC scripts:\n")

        def process_results(query):
            logging.debug(f"Processing query '{query}'")
            # Perform the search and process results
            results = search(query, num_results=(self.limit or link_limit), lang="en")
            cve_links = defaultdict(list)

            for link in results:
                logging.debug(f'Link: {link}')
                cve_id = self.extract_cve_from_link(link)
                if not cve_id:
                    continue

                normalized_id = cve_id.upper()
                if link not in cve_links[normalized_id]:
                    cve_links[normalized_id].append(link)

            return cve_links

        try:
            cve_links = defaultdict(list)
            cve_ids = self.cve_details_provider(tech_name) or []

            if not cve_ids:
                logging.info("No CVEs with 'Potential exploit exists' found.")
                return
            
            for cve_id in cve_ids:
                cve_links.update(process_results(f"{cve_id} site:github.com"))

            if not cve_links:
                logging.info("No script links found.")
                
            else:
                logging.info(f"Found exploits for '{tech_name}':")
                # Sort CVEs from latest to oldest based on CVE year
                sorted_cves = sorted(cve_links.items(), key=lambda item: int(item[0].split('-')[1]), reverse=True)

                # Print the sorted CVE details
                for cve_id, links in sorted_cves:
                    description = self.get_cve_description(cve_id)
                    self.console.print(f"[bold cyan][*][/] CVE-ID: [bold green]{cve_id}[/] :")
                    
                    # Get Gemini Insight for the CVE description
                    insight = self.get_cve_insight(description) or "No description available."
                    self.console.print(f"    Description:\n    {insight.replace('\n', '\n ')}")
                    self.console.print(f"    Scripts:")
                    for link in links:
                        self.console.print(f"    - [bold blue]{link}[/]")
                    self.console.print("")

        except Exception as e:
            logging.error(f"Search failed: {e}")

    def cve_details_provider(self, tect_name, page: int = 1, max_cve: int = 5, retries: int = 5):
        # Constructing the CVE search URL with specific vulnerability filters applied
        url = (
            "https://www.cvedetails.com/vulnerability-search.php?"  # Base search URL
            f"f=1"  # Activate the search form (required field)
            f"&vendor={tect_name}"  # Dynamically insert the vendor name (e.g., 'microsoft', 'apache')
            # Apply specific vulnerability filters:
            f"&optmemory_corruption=1"  # Include memory corruption vulnerabilities
            f"&optsql_injection=1"      # Include SQL injection vulnerabilities
            f"&optdir_traversal=1"      # Include directory traversal vulnerabilities
            f"&optfileinc=1"            # Include file inclusion vulnerabilities
            f"&optxxe=1"                # Include XML External Entity (XXE) vulnerabilities
            f"&optssrf=1"               # Include Server-Side Request Forgery (SSRF) vulnerabilities
            f"&optexeccode=1"           # Include remote/unauthorized code execution vulnerabilities
            f"&optgainpriv=1"           # Include privilege escalation vulnerabilities
            f"&page={page}"             # Specify the page number for paginated results
        )

        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36"
        }

        cve_ids = []
        # Retry fetching the CVE Details page
        for attempt in range(retries):
            try:
                response = requests.get(url, headers=headers)
                
                soup = BeautifulSoup(response.text, "html.parser")
                cve_blocks = soup.find_all("div", class_="border-top py-3 px-2 hover-bg-light", attrs={"data-tsvfield": "cveinfo"})

                for block in cve_blocks:
                    if len(cve_ids) >= max_cve:
                        break  # Stop collecting once the limit is reached

                    exploit_div = block.find("div", attrs={"data-tsvfield": "exploitExistsPotential", "title": "Potential exploit exists"}) # type: ignore
                    if exploit_div:
                        cve_id_tag = block.find("a", href=True)  # type: ignore
                        if cve_id_tag:
                            cve_ids.append(cve_id_tag.text.strip())

                break  # Exit on loop after first success to avoid retries
            except requests.RequestException as e:
                logging.warning(f"[!] Attempt {attempt+1}/{retries} - Failed to fetch CVE data: {e}")
                time.sleep(1)  # Wait before retrying
        else:
            logging.error("All attempts failed to fetch CVE data.")
            return
        
        return cve_ids

    def extract_cve_from_link(self, link):
        """ Helper method to extract CVE from the link or content. """
        match = re.search(r"(CVE-\d{4}-\d{4,7})", link, re.IGNORECASE)
        if match:
            return match.group(1).upper()

        # If no CVE in the URL, try extracting from the content
        cve_ids = self.extract_cve_from_content(link)
        return cve_ids[0] if cve_ids else None

    def searchsploit(self, tech_name):
        logging.info(f"Searching '{tech_name}' on searchsploit (ExploitDB)...")

        try:
            subprocess.run(['searchsploit', tech_name], check=True)

        except FileNotFoundError:
            logging.error("'searchsploit' not found. Please Install ExploitDB (searchsploit).")

    def metasploit_search(self, tech_name):
        logging.info(f"Searching '{tech_name}' on msfconsole (MetaSploit)...")

        try:
            subprocess.run(['msfconsole', '-q', '-x', f"search type:exploit {tech_name}; exit"], check=True)

        except FileNotFoundError:
            logging.error("'msfconsole' not found. Please Install Metasploit Framework.")
    
    def search(self, tech_name, provider):
        if 'google' in provider:
            self.google_dork_search(tech_name)

        if 'metasploit' in provider:
            if self.ask_user('msfconsole'):
                self.metasploit_search(tech_name)

        if 'searchsploit' in provider:
            if self.ask_user('searchsploit'):
                self.searchsploit(tech_name)
